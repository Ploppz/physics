use std::collections::HashMap;
use std::process::exit;
use glium;
use geometry::vec::vec;

pub mod line;

/// Inner workings & public interface for manage of generic buffers.
///
/// Vertex is a struct generated by glium's `implement_vertex`
struct BufferCollection<Vertex> where Vertex: Copy{
    capacity: usize,
    buffers: Vec<Vec<Vertex>>,
    buffer_map: HashMap<String, usize>,
    active_buffer_index: usize,
}

impl<Vertex> BufferCollection<Vertex> where Vertex: Copy {
    fn new(capacity: usize) -> BufferCollection<Vertex> {
        let mut buffers = Vec::new();   // Vec<Vec<f32>>
        buffers.push(Vec::new());

        let mut buffer_map = HashMap::new();
        buffer_map.insert("default".to_string(), 0);

        BufferCollection {
            capacity: capacity,
            buffers: buffers,
            buffer_map: buffer_map,
            active_buffer_index: 0,
        }
    }
    fn clear_buffer(&mut self) {
        self.buffers[self.active_buffer_index].clear();
    }

    fn clear_default_buffer(&mut self) {
        self.buffers[0].clear();
    }

    fn use_buffer(&mut self, name: String) {
        self.active_buffer_index = *self.buffer_map.get(&name).unwrap();
    }

    /// Sets the active buffer to the default one
    fn use_default_buffer(&mut self) {
        self.active_buffer_index = *self.buffer_map.get("default").unwrap();
    }

    /// Pushes an element to the active buffer 
    fn push(&mut self, v: Vertex) {
        self.buffers[self.active_buffer_index].push(v);
        if self.buffers[self.active_buffer_index].len() > self.capacity {
            panic!("ERRORRRR maybe increase the capacity - or remember to clear the buffer between draws.");
        }
    }

    fn get_num_vertices(&self) -> usize {
        let mut total_num_vertices = 0;
        for buffer in &self.buffers {
            total_num_vertices += buffer.len();
        }
        total_num_vertices
    }

    fn upload_all_vertices(&self, vertex_buffer: &mut glium::VertexBuffer<Vertex>) {
        let mut mapping = vertex_buffer.map();
        let total_num_vertices = self.get_num_vertices();

        let mut i = 0;
        for buffer in &self.buffers {
            let mut buffer_i = 0;
            loop {
                mapping[i] = buffer[buffer_i];

                i += 1;
                buffer_i += 1;
                if i >= self.capacity || buffer_i >= buffer.len() {
                    break;
                }
            }
        }
    }
}


pub trait Renderer {
    fn render(&mut self, target: &mut glium::Frame, center: vec, width: u32, height: u32, zoom: f64);
}
